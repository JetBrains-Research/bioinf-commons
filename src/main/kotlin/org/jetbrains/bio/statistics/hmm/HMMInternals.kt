package org.jetbrains.bio.statistics.hmm

import org.jetbrains.bio.dataframe.DataFrame
import org.jetbrains.bio.viktor.F64Array
import org.jetbrains.bio.viktor._I
import kotlin.math.ln

/**
 * Generic algorithms for fitting HMMs.
 *
 * @author Sergei Lebedev
 * @since 09/10/14
 */
object HMMInternals {
    /**
     * Computes the probabilities of form
     *
     *     \alpha_t(i) = P(o_1, o_2, ..., o_t, s_t = i; \theta)
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @param logForwardProbabilities see above for definition.
     */
    @JvmStatic
    fun logForward(
        df: DataFrame, numStates: Int,
        logPriorProbabilities: F64Array,
        logTransitionProbabilities: F64Array,
        logObservationProbabilities: F64Array,
        logForwardProbabilities: F64Array
    ) {
        val numObservations = df.rowsNumber
        for (state in 0 until numStates) {
            logForwardProbabilities[0, state] = logPriorProbabilities[state] +
                    logObservationProbabilities[0, state]
        }

        val workBuffer = F64Array(numStates)
        for (observation in 1 until numObservations) {
            for (state in 0 until numStates) {
                logForwardProbabilities.V[observation - 1].copyTo(workBuffer)
                for (j in 0 until numStates) {
                    workBuffer[j] += logTransitionProbabilities[j, state]
                }

                logForwardProbabilities[observation, state] =
                    workBuffer.logSumExp() + logObservationProbabilities[observation, state]
            }
        }
    }

    /**
     * Computes the probabilities of form
     *
     *     \beta_t(i) = P(o_{t + 1}, o_{t + 2}, ..., o_T| s_t = i; \theta)
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @param logBackwardProbabilities see above for definition.
     */
    @JvmStatic
    fun logBackward(
        df: DataFrame, numStates: Int,
        logTransitionProbabilities: F64Array,
        logObservationProbabilities: F64Array,
        logBackwardProbabilities: F64Array
    ) {
        val numObservations = df.rowsNumber
        logBackwardProbabilities.V[numObservations - 1] = ln(1.0)

        var observation = numObservations - 2
        while (observation >= 0) {
            for (state in 0 until numStates) {
                val workBuffer = logObservationProbabilities.V[observation + 1] +
                        logBackwardProbabilities.V[observation + 1] +
                        logTransitionProbabilities.V[state]

                logBackwardProbabilities[observation, state] = workBuffer.logSumExp()
            }

            observation--
        }
    }

    @JvmStatic
    fun logLikelihood(
        df: DataFrame,
        logForwardProbabilities: F64Array
    ): Double {
        val numObservations = df.rowsNumber
        return logForwardProbabilities.V[numObservations - 1].logSumExp()
    }

    /**
     * Computes posterior state membership probabilities.
     *
     * @param df sample
     * @param logForwardProbabilities see [logForward]
     * @param logBackwardProbabilities see [logBackward]
     * @param logGammas a column-stochastic matrix where the (i, t)-th element
     *                  is the posterior probability that the t-th observation
     *                  was generated by state i.
     */
    @JvmStatic
    fun evaluate(
        df: DataFrame,
        logForwardProbabilities: F64Array,
        logBackwardProbabilities: F64Array,
        logGammas: F64Array
    ) {
        val rowsNumber = df.rowsNumber
        for (observation in 0 until rowsNumber) {
            val workBuffer =
                logForwardProbabilities.V[observation] + logBackwardProbabilities.V[observation]
            workBuffer.logRescale()
            workBuffer.copyTo(logGammas.V[_I, observation])
        }
    }

    /**
     * Computes MLE of the state sequence using Viterbi algorithm.
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @return state sequence.
     */
    @JvmStatic
    fun viterbi(
        df: DataFrame, numStates: Int,
        logPriorProbabilities: F64Array,
        logTransitionProbabilities: F64Array,
        logObservationProbabilities: F64Array
    ): IntArray {
        val numObservations = df.rowsNumber
        val vs = F64Array(numObservations, numStates)
        for (state in 0 until numStates) {
            vs[0, state] = logPriorProbabilities[state] + logObservationProbabilities[0, state]
        }

        val workBuffer = F64Array(numStates)
        for (observation in 1 until numObservations) {
            for (nextState in 0 until numStates) {
                for (priorState in 0 until numStates) {
                    workBuffer[priorState] =
                        vs[observation - 1, priorState] + logTransitionProbabilities[priorState, nextState]
                }

                vs[observation, nextState] = workBuffer.max() + logObservationProbabilities[observation, nextState]
            }
        }

        val states = IntArray(numObservations)
        var whereFrom = vs.V[numObservations - 1].argMax()
        states[numObservations - 1] = whereFrom

        var observation = numObservations - 2
        while (observation >= 0) {
            for (state in 0 until numStates) {
                workBuffer[state] = vs[observation, state] + logTransitionProbabilities[state, whereFrom]
            }

            whereFrom = workBuffer.argMax()
            states[observation] = whereFrom
            observation--
        }

        return states
    }
}