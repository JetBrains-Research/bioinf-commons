package org.jetbrains.bio.statistics.hmm

import org.jetbrains.bio.dataframe.DataFrame
import org.jetbrains.bio.viktor.F64Array
import org.jetbrains.bio.viktor._I

/**
 * Generic algorithms for fitting HMMs.
 *
 * @author Sergei Lebedev
 * @since 09/10/14
 */
object HMMInternals {
    /**
     * Computes the probabilities of form
     *
     *     \alpha_t(i) = P(o_1, o_2, ..., o_t, s_t = i; \theta)
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @param logForwardProbabilities see above for definition.
     */
    @JvmStatic fun logForward(df: DataFrame, numStates: Int,
                              logPriorProbabilities: F64Array,
                              logTransitionProbabilities: F64Array,
                              logObservationProbabilities: F64Array,
                              logForwardProbabilities: F64Array) {
        val numObservations = df.rowsNumber
        for (i in 0 until numStates) {
            logForwardProbabilities[0, i] = logPriorProbabilities[i] +
                                            logObservationProbabilities[0, i]
        }

        val workBuffer = F64Array(numStates)
        for (t in 1 until numObservations) {
            for (i in 0 until numStates) {
                logForwardProbabilities.V[t - 1].copyTo(workBuffer)
                for (j in 0 until numStates) {
                    workBuffer[j] += logTransitionProbabilities[j, i]
                }

                logForwardProbabilities[t, i] =
                        workBuffer.logSumExp() + logObservationProbabilities[t, i]
            }
        }
    }

    /**
     * Computes the probabilities of form
     *
     *     \beta_t(i) = P(o_{t + 1}, o_{t + 2}, ..., o_T| s_t = i; \theta)
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @param logBackwardProbabilities see above for definition.
     */
    @JvmStatic fun logBackward(df: DataFrame, numStates: Int,
                               logTransitionProbabilities: F64Array,
                               logObservationProbabilities: F64Array,
                               logBackwardProbabilities: F64Array) {
        val numObservations = df.rowsNumber
        logBackwardProbabilities.V[numObservations - 1] = Math.log(1.0)

        var t = numObservations - 2
        while (t >= 0) {
            for (i in 0 until numStates) {
                val workBuffer = logObservationProbabilities.V[t + 1] +
                                 logBackwardProbabilities.V[t + 1] +
                                 logTransitionProbabilities.V[i]

                logBackwardProbabilities[t, i] = workBuffer.logSumExp()
            }

            t--
        }
    }

    @JvmStatic fun logLikelihood(df: DataFrame,
                                 logForwardProbabilities: F64Array): Double {
        val numObservations = df.rowsNumber
        return logForwardProbabilities.V[numObservations - 1].logSumExp()
    }

    /**
     * Computes posterior state membership probabilities.
     *
     * @param df sample
     * @param logForwardProbabilities see [.logForward]
     * @param logBackwardProbabilities see [.logBackward]
     * @param logGammas a column-stochastic matrix where the (i, t)-th element
     *                  is the posterior probability that the t-th observation
     *                  was generated by state i.
     */
    @JvmStatic fun evaluate(df: DataFrame,
                            logForwardProbabilities: F64Array,
                            logBackwardProbabilities: F64Array,
                            logGammas: F64Array) {
        val rowsNumber = df.rowsNumber
        for (t in 0 until rowsNumber) {
            val workBuffer = logForwardProbabilities.V[t] +
                             logBackwardProbabilities.V[t]
            workBuffer.logRescale()
            workBuffer.copyTo(logGammas.V[_I, t])
        }
    }

    /**
     * Computes MLE of the state sequence using Viterbi algorithm.
     *
     * @param df sample
     * @param numStates number of states
     * @param logTransitionProbabilities a combined prior and transition
     *                                   probability matrix, where the
     *                                   (t, i, j)-th element is the probability
     *                                   of making an i->j transition at time t.
     * @param logObservationProbabilities a matrix, where the (t, i)-th element
     *                                    is the probability that the t-th
     *                                    observation was generated by state i.
     * @return state sequence.
     */
    @JvmStatic fun viterbi(df: DataFrame, numStates: Int,
                           logPriorProbabilities: F64Array,
                           logTransitionProbabilities: F64Array,
                           logObservationProbabilities: F64Array): IntArray {
        val numObservations = df.rowsNumber
        val vs = F64Array(numObservations, numStates)
        for (i in 0 until numStates) {
            vs[0, i] = logPriorProbabilities[i] + logObservationProbabilities[0, i]
        }

        val workBuffer = F64Array(numStates)
        for (t in 1 until numObservations) {
            for (i in 0 until numStates) {
                for (j in 0 until numStates) {
                    workBuffer[j] = vs[t - 1, j] + logTransitionProbabilities[j, i]
                }

                vs[t, i] = workBuffer.max() + logObservationProbabilities[t, i]
            }
        }

        val states = IntArray(numObservations)
        var whereFrom = vs.V[numObservations - 1].argMax()
        states[numObservations - 1] = whereFrom

        var t = numObservations - 2
        while (t >= 0) {
            for (i in 0 until numStates) {
                workBuffer[i] = vs[t, i] + logTransitionProbabilities[i, whereFrom]
            }

            whereFrom = workBuffer.argMax()
            states[t] = whereFrom
            t--
        }

        return states
    }
}